## 一、项目概述

本项目目标是为 tRPC-Cpp 设计并实现一套**灵活、高性能、线程安全**的 LRU Cache 组件，覆盖服务端与客户端，包括协议、编解码、代理等场景。

必需功能包括：

- 基础 LRU 逻辑（Put/Get/Evict）。
  - 实现最近最少使用淘汰策略，保证核心缓存功能可用。
- 多线程安全接口（支持框架提供同步原语 Mutex/FiberMutex）。
  - 适配 tRPC 的多线程/协程模型，确保并发操作的正确性。
- 自定义 Key/Value 支持（模板化接口）。
  - 允许用户使用业务自定义类型作为缓存键值，提升灵活性。
- 监控缓存统计（命中率、淘汰次数、内存占用）。
  - 帮助用户优化缓存策略。

可选功能包括：

- 支持设置缓存的过期时间。
  - 自动淘汰过期数据。
  - 惰性淘汰。
- 运行时调整缓存容量。
  - 支持弹性扩缩容。



## 二、项目规划

![LRU Cache 项目规划](image/project_plan.svg)

规划思路：先完成再完美——先构建最简单的原型跑通流程（包含单元测试、基准测试、系统端到端的功能测试）；再逐步对算法进行迭代优化。



## 三、项目成果物列表

|  成果物  |                                        内容                                         | 状态  |
| :------: | :---------------------------------------------------------------------------------: | :---: |
|  源代码  |                              1. 实现<br />2. Unit Test                              |       |
| 说明文档 | 1. 算法实现，优化点说明<br />2. Benchmark 环境搭建说明<br />3. 与其他实现的性能对比 |       |
| 使用文档 |                   类似 hello world 的 example（举出几个应用场景）                   |       |

## 四、算法调研
leetcode：[146. LRU 缓存](https://leetcode.cn/problems/lru-cache/description/)
| 时间复杂度 | 空间复杂度 |     存储结构      | 淘汰机制 |
| :--------: | :--------: | :---------------: | :------: |
|    O(1)    |    O(n)    | 哈希表 + 双向链表 | 尾部淘汰 |

使用伪造头部和伪造尾部节点，避免处理空指针情况
leveldb: [LRUCache](https://github.com/google/leveldb)
| 时间复杂度 | 空间复杂度 |     存储结构      | 淘汰机制 |
| :--------: | :--------: | :---------------: | :------: |
|    O(1)    |    O(n)    | 哈希表 + 双向链表 | 尾部淘汰 |

LRU缓存维护两个独立的双向循环链表:lru_链表：存储未被引用的条目，按LRU顺序排列（最新在前，最旧在后）
in_use_链表：存储当前被客户端引用的条目
整个缓存系统采用分片设计，每个分片维护一个独立的LRU缓存
rocksdb: [LRUCache](https://github.com/facebook/rocksdb)
| 时间复杂度 | 空间复杂度 |       存储结构        |     淘汰机制     |
| :--------: | :--------: | :-------------------: | :--------------: |
|    O(1)    |    O(n)    | 哈希表 + 循环双向链表 | 多优先级尾部淘汰 |

多优先级淘汰机制：RocksDB的LRU缓存实现了三级优先级池系统，通过不同的优先级来优化缓存命中率和性能，当某个池超出容量时，会将溢出的元素降级到下一个优先级池
分片机制：缓存被分割成2^num_shard_bits个分片，通过哈希值的低位来选择分片，每个分片维护一个独立的LRU缓存
CacheLib [LRUCache](https://github.com/facebook/CacheLib)
| 时间复杂度 | 空间复杂度 |        存储结构         |                淘汰机制                |
| :--------: | :--------: | :---------------------: | :------------------------------------: |
|    O(1)    |    O(n)    | 哈希表 + 侵入式双向链表 | 尾部淘汰+NVM缓存+搜索重试机制+频率淘汰 |

MMLru实现标准的LRU淘汰，从链表尾部开始提供淘汰迭代器
MM2Q实现更复杂的淘汰顺序，按照ColdTail → Cold → WarmTail → Warm → Hot的顺序进行淘汰。
MMTinyLFU基于频率进行淘汰决策，会比较tiny队列和main队列尾部项目的访问频率
